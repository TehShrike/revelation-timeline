{{#if hoveredEvent}}
<div class="eventhover">
	{{hoveredEvent.title}} {{#if hoveredEvent.reference}}({{hoveredEvent.reference}}){{/if}}
</div>
{{/if}}
<div class="timeline-container">
	<div class="timeline-row" style="width: 100px; margin-right: 10px;">
		{{#each axis as date}}
		<VCenter point="{{multiplyDaysByHeight(distanceFromStartDay(date.axisPoint))}}">
			<div class="axis" data-relevant="{{axisIsRelevant(date.amd)}}">
				{{#if date.type === 'snip'}}
				...snip ({{date.days}} days)
				{{else}}
				{{date.hebrew || date.amd}}
				{{/if}}
			</div>
		</VCenter>
		{{/each}}
	</div>
	<div class="timeline-row" style="width: 250px">
		<Events
			timeline="{{relevantEventsWithAxis}}"
			on:startHover="startHover(event)"
			on:endHover="endHover(event)"
			dayHeight="{{currentZoom.dayHeight}}"
			clickable="{{true}}"
		/>
	</div>
</div>
<style>
.timeline-container {
	display: flex;
	flex-wrap: nowrap;
	align-items: flex-start;
}
.timeline-row {
	position: relative;
}
.axis {
	font-size: 10px;
	width: 100px;
	text-align: right;
}
.axis[data-relevant=true] {
	color: red;
}
.eventhover {
	z-index: 1;
	position: fixed;
	top: 0;
	left: 0;
	padding: 10px;
	background-color: white;
	background-color: rgba(255, 255, 255, 0.8);
}
</style>
<script>
import VCenter from './VerticallyCentered.html'
import Events from './Events.html'
import createTimelineAxis from './create-timeline-axis.js'
import addAxisPoints from '../timeline-data/add-axis-points-to-timeline-data.js'
import { multiplyIndentByWidth } from './spacer-functions.js'
import sortRange from '../timeline-data/sort-range.js'
import pipe from './pipe.js'

import chromatism from 'chromatism'

function createIndentLevelCalculator() {
	const indentLevels = []
	return event => {
		const eventDate = event.amd
		const replaceIndent = indentLevels.findIndex(previousDate => previousDate.end < eventDate.start)
		if (replaceIndent === -1) {
			indentLevels.push(eventDate)
			return indentLevels.length - 1
		} else {
			indentLevels[replaceIndent] = eventDate
			return replaceIndent
		}
	}
}
function addIndentAndAxisAfterStart(events, startDay, endDay) {
	const getIndentLevel = createIndentLevelCalculator()
	return events.map(event => {
		if (event.axis.start === undefined || event.axis.end === undefined) {
			console.error(event)
			throw new Error(`No axis values for ${event.title}`)
		}
		const axisAfterStart = Math.max(event.axis.start - startDay, 0)
		const eventDays = event.axis.end - event.axis.start + 1
		const daysBeforeStart = Math.max(startDay - event.axis.start, 0)
		const daysAfterEnd = Math.max(event.axis.end - endDay, 0)
		const visibleDays = eventDays - daysBeforeStart - daysAfterEnd
		return Object.assign({
			indentLevel: getIndentLevel(event),
			axisAfterStart,
			visibleDays
		}, event)
	})
}

const topZoom = {
	dayHeight: 0.1,
	start: 1471937,
	end: 1488003,
	snipSectionsLongerThan: 10000,
	snipBuffer: 1500,
	type: 'top',
}

function eventOverlapsRange(eventRange, zoomRange) {
	const solidlyInside = eventRange.start >= zoomRange.start && eventRange.end <= zoomRange.end
	const overlapsBeginning = eventRange.end >= zoomRange.start && eventRange.start < zoomRange.start
	const overlapsEnd = eventRange.start <= zoomRange.end && eventRange.end > zoomRange.end
	
	return solidlyInside || overlapsBeginning || overlapsEnd
}

function daysThatOverlapRange(eventRange, zoomRange) {
	const eventDays = eventRange.end - eventRange.start
	const lostAtStart = Math.max(zoomRange.start - eventRange.start, 0)
	const lostAtEnd = Math.max(eventRange.end - zoomRange.end, 0)

	return eventDays - lostAtStart - lostAtEnd
}

// const startingColor = '#2900ff'
// const startingColor = '#00cdd4'
// const endingColor = '#00ccd4'
const startingColor = '#0074D9'
const endingColor = '#2ECC40'
// const eventColors = chromatism.adjacent(20, 5, startingColor).hex
const eventColors = chromatism.fade(4, startingColor, endingColor).hex
const hoverColors = eventColors.map(color => chromatism.contrast(3, color).hex)
console.log(eventColors)
function addColorToEvents(events) {
	return events.map((event, i) => Object.assign({
		color: eventColors[event.indentLevel % eventColors.length],
		hoverColor: hoverColors[event.indentLevel % eventColors.length]
	}, event))
}

function filterToRelevantEvents(timelineData, currentZoom) {
	return timelineData.filter(
		event => eventOverlapsRange(event.amd, currentZoom) 
			&& (!currentZoom.type || currentZoom.type === event.type)
	)
}

function sortEventsForDisplay(timelineData, currentZoom) {
	return sortRange(timelineData,
		event => event.type === 'top' 
			? [ 0, -daysThatOverlapRange(event.amd, currentZoom), 0 ]
			: [ 1, event.amd.start, -daysThatOverlapRange(event.amd, currentZoom) ]
	)
}

export default {
	computed: {
		zooms: timelineData => timelineData.reduce((map, event) => {
			map[event.slug] = {
				start: event.amd.start,
				end: event.amd.end,
				dayHeight: 15000 / Math.floor((event.amd.end - event.amd.start)),
				snipSectionsLongerThan: 300,
				snipBuffer: 50
			}
			return map
		}, {
			top: topZoom
		}),
		multiplyDaysByHeight: currentZoom => days => days * currentZoom.dayHeight,
		relevantEvents: (timelineData, currentZoom) => pipe(timelineData,
			timelineData => filterToRelevantEvents(timelineData, currentZoom),
			timelineData => sortEventsForDisplay(timelineData, currentZoom)
		),
		axis: (relevantEvents, currentZoom) => createTimelineAxis({
			timelineData: relevantEvents,
			snipSectionsLongerThan: currentZoom.snipSectionsLongerThan,
			snipBuffer: currentZoom.snipBuffer,
			start: currentZoom.start,
			end: currentZoom.end,
		}),
		relevantEventsWithAxis: (axis, relevantEvents, currentZoom) => pipe(relevantEvents,
			_ => addAxisPoints(axis, _),
			_ => addIndentAndAxisAfterStart(_, currentZoom.start, currentZoom.end),
			addColorToEvents
		),
		distanceFromStartDay: currentZoom => day => day - currentZoom.start,
		axisIsRelevant: hoveredEvent => amdDay => !!hoveredEvent
			&& (hoveredEvent.amd.start === amdDay || hoveredEvent.amd.end === amdDay),
		currentZoom: (querystringParameters, zooms) =>
			(querystringParameters.zoom && zooms[querystringParameters.zoom])
				? zooms[querystringParameters.zoom]
				: topZoom
	},
	helpers: {
		multiplyIndentByWidth,
	},
	methods: {
		startHover(event) {
			this.set({
				hoveredEvent: event
			})
		},
		endHover() {
			this.set({
				hoveredEvent: null
			})
		},
	},
	components: {
		VCenter,
		Events
	},
}
</script>
