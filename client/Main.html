{{#if hoveredEvent}}
<div class="eventhover">
	{{hoveredEvent.title}} ({{hoveredEvent.hebrew.start}} to {{hoveredEvent.hebrew.end}})
</div>
{{/if}}
<div class="timeline-container">
	{{#each axis as date}}
	<VCenter left="-110" top="{{multiplyDaysByHeight(distanceFromStartDay(date.axisPoint))}}">
		<span class="axis">
			{{#if date.type === 'snip'}}
			...snip ({{date.days}} days)
			{{else}}
			{{date.hebrew || date.amd}}
			{{/if}}			
		</span>
	</VCenter>
	{{/each}}
	{{#each relevantTimelineData as timelineEvent}}
		<div 
			class="event" 
			data-title="{{timelineEvent.title}}" 
			style="
				top: {{multiplyDaysByHeight(timelineEvent.axisAfterStart)}}px; 
				height: {{multiplyDaysByHeight(timelineEvent.axis.end - timelineEvent.axis.start)}}px;
				left: {{multiplyIndentByWidth(timelineEvent.indentLevel)}}px;
			"
			on:mouseover="startHover(timelineEvent)"
			on:mouseleave="endHover(timelineEvent)"

		>
			
		</div>
	{{/each}}	
</div>

<style>
.timeline-container {
	position: relative;
}
.axis {
	font-size: 10px;
	width: 100px;
	float: right;
	text-align: right;
}
.event {
	position: absolute;
	width: 16px;
	-webkit-border-radius: 10px;
	-moz-border-radius: 10px;
	border-radius: 10px;

	background-color: green;
}
.event:hover {
	background-color: red;
}

.eventhover {
	position: fixed;
	top: 0;
	left: 0;
	padding: 10px;
}
</style>

<script>
function mapKnowingPrevious(ary, fn) {
	let last = null
	return ary.map(current => {
		const transformed = fn(current, last)
		last = transformed
		return transformed
	})
}

import VCenter from './VerticallyCentered.html'

import filterAndSort from '../timeline-data/filter-and-sort.js'
import createTimelineAxis from '../timeline-data/create-timeline-axis.js'
import addAxisPoints from '../timeline-data/add-axis-points-to-timeline-data.js'

export default {
	computed: {
		relevantEvents: timelineData => filterAndSort(timelineData),
		axis: relevantEvents => createTimelineAxis(relevantEvents, 50),
		startDay: relevantEvents => relevantEvents[0].amd.start,
		relevantEventsWithAxis: (axis, relevantEvents) => addAxisPoints(axis, relevantEvents),
		relevantTimelineData: (relevantEventsWithAxis, startDay) => {
			return mapKnowingPrevious(
				relevantEventsWithAxis,
				(event, previous) => {
					const calculatedIndentLevel = () => previous.amd.end >= event.amd.start 
						? previous.indentLevel + 1 
						: previous.indentLevel

					const indentLevel = previous ? calculatedIndentLevel() : 0

					return Object.assign({
						indentLevel,
						axisAfterStart: event.axis.start - startDay
					}, event)
				}
			)
		},
		distanceFromStartDay: startDay => day => day - startDay
	},
	helpers: {
		multiplyDaysByHeight(days) {
			return (days + 1) * 3
		},
		multiplyIndentByWidth(indentLevel) {
			return indentLevel * 20
		}
	},
	methods: {
		startHover(event) {
			this.set({
				hoveredEvent: event
			})
		},
		endHover() {
			this.set({
				hoveredEvent: null
			})
		}
	},
	components: {
		VCenter
	}
}
</script>
