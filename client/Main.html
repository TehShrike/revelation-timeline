{{#if hoveredEvent}}
<div class="eventhover">
	{{hoveredEvent.title}} {{#if hoveredEvent.reference}}({{hoveredEvent.reference}}){{/if}}
</div>
{{/if}}
<button class="btn-default" id="zoombutton" on:click="toggleZoom()">Zoom {{#if zoomedIn}}out{{else}}in{{/if}}</button>
<div class="timeline-container">
	<div class="timeline-row" style="width: 100px; margin-right: 10px;">
		{{#each axis as date}}
		<VCenter point="{{multiplyDaysByHeight(distanceFromStartDay(date.axisPoint))}}">
			<div class="axis" data-relevant="{{axisIsRelevant(date.amd)}}">
				{{#if date.type === 'snip'}}
				...snip ({{date.days}} days)
				{{else}}
				{{date.hebrew || date.amd}}
				{{/if}}			
			</div>
		</VCenter>
		{{/each}}		
	</div>
	<div class="timeline-row" style="width: 50px">
		<Events 
			timeline="{{times}}" 
			on:startHover="startHover(event)" 
			on:endHover="endHover(event)" 
			dayHeight="{{dayHeight}}"
		/>
	</div>
	<div class="timeline-row" style="width: 200px">
		<Events 
			timeline="{{otherEvents}}" 
			on:startHover="startHover(event)" 
			on:endHover="endHover(event)" 
			dayHeight="{{dayHeight}}"
		/>
	</div>
</div>

<style>
.timeline-container {
	display: flex;
	flex-wrap: nowrap;
	align-items: flex-start;
}
.timeline-row {
	position: relative;
}
.axis {
	font-size: 10px;
	width: 100px;
	text-align: right;
}
.axis[data-relevant=true] {
	color: red;
}
.event {
	width: 16px;
	-webkit-border-radius: 10px;
	-moz-border-radius: 10px;
	border-radius: 10px;

	background-color: green;
}
.event:hover {
	background-color: red;
}

.eventhover {
	z-index: 1;
	position: fixed;
	top: 0;
	left: 0;
	padding: 10px;
	background-color: white;
	background-color: rgba(255, 255, 255, 0.8);
}
#zoombutton {
	z-index: 1;
	position: fixed;
	top: 0;	
	right: 0;
}
</style>

<script>
function mapKnowingPrevious(ary, fn) {
	let last = null
	return ary.map(current => {
		const transformed = fn(current, last)
		last = transformed
		return transformed
	})
}

import VCenter from './VerticallyCentered.html'
import Events from './Events.html'

import filterAndSort from '../timeline-data/filter-and-sort.js'
import createTimelineAxis from '../timeline-data/create-timeline-axis.js'
import addAxisPoints from '../timeline-data/add-axis-points-to-timeline-data.js'

import { multiplyIndentByWidth } from './spacer-functions.js'

function addIndentAndAxisAfterStart(events, startDay) {
	return mapKnowingPrevious(
		events,
		(event, previous) => {
			const calculatedIndentLevel = () => previous.amd.end >= event.amd.start 
				? previous.indentLevel + 1 
				: previous.indentLevel

			const indentLevel = previous ? calculatedIndentLevel() : 0

			return Object.assign({
				indentLevel,
				axisAfterStart: event.axis.start - startDay
			}, event)
		}
	)	
}

const zoomedIn = {
	snipSectionsLongerThan: 300,
	snipBuffer: 10,
	dayHeight: 10,
	minimumLength: 1,
	zoomedIn: true
}
const zoomedOut = {
	snipSectionsLongerThan: 10000,
	snipBuffer: 50,
	dayHeight: 0.05,
	minimumLength: 100,
	zoomedIn: false
}

export default {
	data() {
		return zoomedOut
	},
	computed: {
		multiplyDaysByHeight: dayHeight => days => days * dayHeight,
		startDay: relevantEvents => relevantEvents[0].amd.start,
		relevantEvents: (timelineData, minimumLength) => filterAndSort(timelineData, minimumLength),
		axis: (relevantEvents, snipSectionsLongerThan, snipBuffer) => createTimelineAxis(relevantEvents, snipSectionsLongerThan, snipBuffer),
		relevantEventsWithAxis: (axis, relevantEvents) => addAxisPoints(axis, relevantEvents),
		times: (relevantEventsWithAxis, startDay) => {
			return addIndentAndAxisAfterStart(
				relevantEventsWithAxis.filter(({ type }) => type === 'time'),
				startDay
			)
		},
		otherEvents: (relevantEventsWithAxis, startDay) => {
			return addIndentAndAxisAfterStart(
				relevantEventsWithAxis.filter(({ type }) => !type),
				startDay
			)
		},
		distanceFromStartDay: startDay => day => day - startDay,
		axisIsRelevant: hoveredEvent => amdDay => !!hoveredEvent 
			&& (hoveredEvent.amd.start === amdDay || hoveredEvent.amd.end === amdDay)
	},
	helpers: {
		multiplyIndentByWidth,
	},
	methods: {
		startHover(event) {
			this.set({
				hoveredEvent: event
			})
		},
		endHover() {
			this.set({
				hoveredEvent: null
			})
		},
		toggleZoom() {
			if (this.get('zoomedIn')) {
				this.set(zoomedOut)
			} else {
				this.set(zoomedIn)				
			}
		}
	},
	components: {
		VCenter,
		Events
	}
}
</script>
