{{#if hoveredEvent}}
<div class="eventhover">
	{{hoveredEvent.title}} ({{hoveredEvent.hebrew.start}} to {{hoveredEvent.hebrew.end}})
</div>
{{/if}}
<div class="timeline-container">
	<div class="timeline-row" style="width: 100px; margin-right: 10px;">
		{{#each axis as date}}
		<VCenter point="{{multiplyDaysByHeight(distanceFromStartDay(date.axisPoint))}}">
			<div class="axis">
				{{#if date.type === 'snip'}}
				...snip ({{date.days}} days)
				{{else}}
				{{date.hebrew || date.amd}}
				{{/if}}			
			</div>
		</VCenter>
		{{/each}}		
	</div>
	<div class="timeline-row" style="width: 50px">
		<Events timeline="{{times}}" on:startHover="startHover(event)" on:endHover="endHover(event)" />
	</div>
	<div class="timeline-row" style="width: 200px">
		<Events timeline="{{otherEvents}}" on:startHover="startHover(event)" on:endHover="endHover(event)" />
	</div>
</div>

<style>
.timeline-container {
	display: flex;
	flex-wrap: nowrap;
	align-items: flex-start;
}
.timeline-row {
	position: relative;
}
.axis {
	font-size: 10px;
	width: 100px;
	text-align: right;
}
.event {
	width: 16px;
	-webkit-border-radius: 10px;
	-moz-border-radius: 10px;
	border-radius: 10px;

	background-color: green;
}
.event:hover {
	background-color: red;
}

.eventhover {
	position: fixed;
	top: 0;
	left: 0;
	padding: 10px;
}
</style>

<script>
function mapKnowingPrevious(ary, fn) {
	let last = null
	return ary.map(current => {
		const transformed = fn(current, last)
		last = transformed
		return transformed
	})
}

import VCenter from './VerticallyCentered.html'
import Events from './Events.html'

import filterAndSort from '../timeline-data/filter-and-sort.js'
import createTimelineAxis from '../timeline-data/create-timeline-axis.js'
import addAxisPoints from '../timeline-data/add-axis-points-to-timeline-data.js'

import { multiplyDaysByHeight, multiplyIndentByWidth } from './spacer-functions.js'

function addIndentAndAxisAfterStart(events, startDay) {
	return mapKnowingPrevious(
		events,
		(event, previous) => {
			const calculatedIndentLevel = () => previous.amd.end >= event.amd.start 
				? previous.indentLevel + 1 
				: previous.indentLevel

			const indentLevel = previous ? calculatedIndentLevel() : 0

			return Object.assign({
				indentLevel,
				axisAfterStart: event.axis.start - startDay
			}, event)
		}
	)	
}

export default {
	computed: {
		relevantEvents: timelineData => filterAndSort(timelineData),
		axis: relevantEvents => createTimelineAxis(relevantEvents, 50),
		startDay: relevantEvents => relevantEvents[0].amd.start,
		relevantEventsWithAxis: (axis, relevantEvents) => addAxisPoints(axis, relevantEvents),
		times: (relevantEventsWithAxis, startDay) => {
			return addIndentAndAxisAfterStart(
				relevantEventsWithAxis.filter(({ type }) => type === 'time'),
				startDay
			)
		},
		otherEvents: (relevantEventsWithAxis, startDay) => {
			return addIndentAndAxisAfterStart(
				relevantEventsWithAxis.filter(({ type }) => !type),
				startDay
			)
		},
		distanceFromStartDay: startDay => day => day - startDay
	},
	helpers: {
		multiplyDaysByHeight,
		multiplyIndentByWidth,
	},
	methods: {
		startHover(event) {
			this.set({
				hoveredEvent: event
			})
		},
		endHover() {
			this.set({
				hoveredEvent: null
			})
		}
	},
	components: {
		VCenter,
		Events
	}
}
</script>
