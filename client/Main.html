{{#if hoveredEvent}}
<div class="eventhover">
	{{hoveredEvent.title}} {{#if hoveredEvent.reference}}({{hoveredEvent.reference}}){{/if}}
</div>
{{/if}}
<button class="btn-default" id="zoombutton" on:click="toggleZoom()">Zoom {{#if zoomedIn}}out{{else}}in{{/if}}</button>
<div class="timeline-container">
	<div class="timeline-row" style="width: 100px; margin-right: 10px;">
		{{#each axis as date}}
		<VCenter point="{{multiplyDaysByHeight(distanceFromStartDay(date.axisPoint))}}">
			<div class="axis" data-relevant="{{axisIsRelevant(date.amd)}}">
				{{#if date.type === 'snip'}}
				...snip ({{date.days}} days)
				{{else}}
				{{date.hebrew || date.amd}}
				{{/if}}			
			</div>
		</VCenter>
		{{/each}}		
	</div>
	<div class="timeline-row" style="width: 50px">
		<Events 
			timeline="{{times}}" 
			on:startHover="startHover(event)" 
			on:endHover="endHover(event)" 
			dayHeight="{{dayHeight}}"
		/>
	</div>
	<div class="timeline-row" style="width: 200px">
		<Events 
			timeline="{{otherEvents}}" 
			on:startHover="startHover(event)" 
			on:endHover="endHover(event)" 
			dayHeight="{{dayHeight}}"
		/>
	</div>
</div>

<style>
.timeline-container {
	display: flex;
	flex-wrap: nowrap;
	align-items: flex-start;
}
.timeline-row {
	position: relative;
}
.axis {
	font-size: 10px;
	width: 100px;
	text-align: right;
}
.axis[data-relevant=true] {
	color: red;
}
.event {
	width: 16px;
	-webkit-border-radius: 10px;
	-moz-border-radius: 10px;
	border-radius: 10px;

	background-color: green;
}
.event:hover {
	background-color: red;
}

.eventhover {
	z-index: 1;
	position: fixed;
	top: 0;
	left: 0;
	padding: 10px;
	background-color: white;
	background-color: rgba(255, 255, 255, 0.8);
}
#zoombutton {
	z-index: 1;
	position: fixed;
	top: 0;	
	right: 0;
}
</style>

<script>
function mapKnowingPrevious(ary, fn) {
	let last = null
	return ary.map(current => {
		const transformed = fn(current, last)
		last = transformed
		return transformed
	})
}

import VCenter from './VerticallyCentered.html'
import Events from './Events.html'

import filterAndSort from '../timeline-data/filter-and-sort.js'
import createTimelineAxis from '../timeline-data/create-timeline-axis.js'
import addAxisPoints from '../timeline-data/add-axis-points-to-timeline-data.js'

import { multiplyIndentByWidth } from './spacer-functions.js'

function addIndentAndAxisAfterStart(events, startDay) {
	return mapKnowingPrevious(
		events,
		(event, previous) => {
			const calculatedIndentLevel = () => previous.amd.end >= event.amd.start 
				? previous.indentLevel + 1 
				: previous.indentLevel

			const indentLevel = previous ? calculatedIndentLevel() : 0

			return Object.assign({
				indentLevel,
				axisAfterStart: event.axis.start - startDay
			}, event)
		}
	)	
}

const zoomedIn = {
	snipSectionsLongerThan: 300,
	snipBuffer: 50,
	dayHeight: 10,
	minimumLength: 1,
	zoomedIn: true
}
const zoomedOut = {
	snipSectionsLongerThan: 300,
	snipBuffer: 50,
	dayHeight: 0.5,
	minimumLength: 100,
	zoomedIn: false
}

const now = (performance && performance.now) 
	? () => performance.now() 
	: Date.now

export default {
	data() {
		return zoomedOut
	},
	computed: {
		multiplyDaysByHeight: dayHeight => days => days * dayHeight,
		startDay: relevantEvents => relevantEvents[0].amd.start,
		relevantEvents: (timelineData, minimumLength) => filterAndSort(timelineData, minimumLength),
		axis: (relevantEvents, snipSectionsLongerThan, snipBuffer) => createTimelineAxis(relevantEvents, snipSectionsLongerThan, snipBuffer),
		relevantEventsWithAxis: (axis, relevantEvents) => addAxisPoints(axis, relevantEvents),
		times: (relevantEventsWithAxis, startDay) => {
			return addIndentAndAxisAfterStart(
				relevantEventsWithAxis.filter(({ type }) => type === 'time'),
				startDay
			)
		},
		otherEvents: (relevantEventsWithAxis, startDay) => {
			return addIndentAndAxisAfterStart(
				relevantEventsWithAxis.filter(({ type }) => !type),
				startDay
			)
		},
		distanceFromStartDay: startDay => day => day - startDay,
		axisIsRelevant: hoveredEvent => amdDay => !!hoveredEvent 
			&& (hoveredEvent.amd.start === amdDay || hoveredEvent.amd.end === amdDay)
	},
	helpers: {
		multiplyIndentByWidth,
	},
	methods: {
		startHover(event) {
			this.set({
				hoveredEvent: event
			})
		},
		endHover() {
			this.set({
				hoveredEvent: null
			})
		},
		toggleZoom() {
			if (this.get('zoomedIn')) {
				this.transitionTo(zoomedOut, 2000).then(() => {
					this.set({
						minimumLength: zoomedOut.minimumLength
					})
				})
			} else {
				this.set({
					minimumLength: zoomedIn.minimumLength
				})
				this.transitionTo(zoomedIn, 2000)				
			}
		},
		transitionTo(destination, totalMs) {
			return new Promise(resolve => {
				const start = now()
				const transitionKeys = [
					'snipSectionsLongerThan',
					'snipBuffer',
					'dayHeight',
				]

				const startData = this.get()

				const differences = transitionKeys
					.reduce((map, key) => {
						map[key] = destination[key] - startData[key]
						return map
					}, {})

				const tick = () => {
					const elapsedMs = now() - start
					if (elapsedMs >= totalMs) {
						// console.log('arrived at', destination)
						this.set(destination)
						resolve()
					} else {
						const ratioElapsed = elapsedMs / totalMs
						// console.log('ratio elapsed', ratioElapsed)
						const stepData = transitionKeys.reduce((acc, key) => {
							acc[key] = startData[key] + (differences[key] * ratioElapsed)
							return acc
						}, {})
						// console.log('stepping to', stepData)
						this.set(stepData)
						window.requestAnimationFrame(tick)
					}
				}

				window.requestAnimationFrame(tick)
			})
		}
	},
	components: {
		VCenter,
		Events
	}
}
</script>
